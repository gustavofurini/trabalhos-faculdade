# -*- coding: utf-8 -*-
"""tde3-grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14l4Df_z4JooAPEUY-1flFwLV4ru4dOIo
"""

from collections import defaultdict
import os
from queue import Queue

class Grafo:
    # Definindo a classe Grafo
    def __init__(self):
        # Construtor para inicializar o grafo
        self.lista_adjacencia = defaultdict(list)  # Lista de adjacência para armazenar as arestas
        self.vertices = []  # Lista para armazenar os vértices do grafo
        self.ordem = 0  # Número de vértices no grafo
        self.tamanho = 0  # Número de arestas no grafo

    # Método para verificar se existe uma aresta entre dois vértices
    def tem_aresta(self, u, v):
        if all(x in self.vertices for x in [u, v]):  # Verifica se os vértices estão no grafo
            for adj in self.lista_adjacencia[u]:
                if adj[0] == v:  # Verifica se v é adjacente a u
                    return True
            return False
        else:
            return False

    # Método para adicionar um vértice ao grafo
    def adiciona_vertice(self, u):
        if u not in self.vertices:  # Verifica se o vértice já foi adicionado
            self.ordem += 1  # Incrementa o número de vértices
            self.vertices.append(u)  # Adiciona o vértice à lista de vértices
            self.lista_adjacencia[u] = []  # Inicializa a lista de adjacência para o novo vértice

    # Método para adicionar uma aresta ao grafo
    def adiciona_aresta(self, u, v, peso):
        # Verifica se a aresta já existe, se não, adiciona-a ou atualiza o peso
        nao_achou = not self.tem_aresta(u,v)
        if (nao_achou):
            self.tamanho += 1  # Incrementa o número de arestas
            self.lista_adjacencia[u].append((v, peso))  # Adiciona a aresta à lista de adjacência de u
        else:
            for i in range(len(self.lista_adjacencia[u])):
                if self.lista_adjacencia[u][i][0] == v:  # Atualiza o peso se a aresta já existe
                    peso += self.lista_adjacencia[u][i][1]
                    self.lista_adjacencia[u].remove(self.lista_adjacencia[u][i])
                    break
            self.tamanho += 1
            self.lista_adjacencia[u].append((v, peso))

    # Método para remover uma aresta do grafo
    def remove_aresta(self, u, v):
        remover = None
        if self.tem_aresta(u, v):  # Verifica se a aresta existe
            for adj in range(len(self.lista_adjacencia[u])):
                if self.lista_adjacencia[u][adj][0] == v:  # Procura a adjacência
                    remover = self.lista_adjacencia[u][adj]
            self.lista_adjacencia[u].remove(remover)  # Remove a adjacência

    # Método para remover um vértice do grafo
    def remove_vertice(self, u):
        if u in self.vertices:  # Verifica se o vértice existe
            self.lista_adjacencia.pop(u)  # Remove o vértice da lista de adjacência
            self.vertices.remove(u)  # Remove o vértice da lista de vértices
            # Remove as adjacências existentes entre outros vértices e u
            for vertice in self.lista_adjacencia:
                for adj in self.lista_adjacencia[vertice]:
                    if adj[0] == u:
                        self.lista_adjacencia[vertice].remove(adj)

    # Método para obter o peso de uma aresta entre dois vértices
    def peso(self, u, v):
        achou = False
        if all(x in self.vertices for x in [u, v]):  # Verifica se os vértices existem
            for adj in self.lista_adjacencia[u]:  # Procura a adjacência
                if adj[0] == v:
                    print(f'O peso entre {u} e {v} é {adj[1]}')
                    achou = True
            if not achou:
                print(f"{u} e {v} não são adjacentes")
        else:
            print(f"Os vértices {u} ou {v} não foram adicionados")

    # Método para calcular o grau de um vértice
    def grau(self, u):
        if u in self.vertices:  # Verifica se o vértice existe
            grau_saida = len(self.lista_adjacencia[u])  # Calcula o grau de saída
            grau_entrada = 0
            for vertice in self.lista_adjacencia:  # Calcula o grau de entrada
                if vertice != u:
                    for adj in self.lista_adjacencia[vertice]:
                        if adj[0] == u:
                            grau_entrada += 1
            return grau_entrada, grau_saida, grau_entrada + grau_saida  # Retorna o grau de entrada, saída e total
        else:
            print(f"O vértice {u} não foi adicionado")

    # Método para obter o número de vértices no grafo
    def num_vertices(self):
        return self.ordem

    # Método para obter o número de arestas no grafo
    def num_arestas(self):
        return self.tamanho

    # Método para imprimir os 20 vértices com maiores graus de entrada
    def vinte_maiores_graus_entrada(self):
        graus = []
        for vertice in self.lista_adjacencia:
            graus.append((vertice, self.grau(vertice)[0]))  # Calcula o grau de entrada de cada vértice
        graus.sort(reverse=True, key=lambda a: a[1])  # Ordena os vértices por grau de entrada
        for i in range(20):
            print(graus[i])

    # Método para imprimir os 20 vértices com maiores graus de saída
    def vinte_maiores_graus_saida(self):
        graus = []
        for vertice in self.lista_adjacencia:
            graus.append((vertice, len(self.lista_adjacencia[vertice])))  # Calcula o grau de saída de cada vértice
        graus.sort(reverse=True, key=lambda a: a[1])  # Ordena os vértices por grau de saída
        for i in range(20):
            print(graus[i])

    # Método auxiliar para encontrar todos os caminhos entre dois vértices
    def encontra_caminhos(self, origem, destino, caminho_atual=[], visitados=None):
        if visitados is None:
            visitados = set()
        visitados.add(origem)
        caminho_atual = caminho_atual + [origem]
        if origem == destino:
            return [caminho_atual]
        if origem not in self.lista_adjacencia:
            return []
        caminhos = []
        for vizinho, _ in self.lista_adjacencia[origem]:
            if vizinho not in visitados:
                novos_caminhos = self.encontra_caminhos(vizinho, destino, caminho_atual, visitados)
                for novo_caminho in novos_caminhos:
                    caminhos.append(novo_caminho)
        return caminhos


    # Método para encontrar o maior caminho mínimo entre dois vértices
    def maior_caminho_minimo(self, origem, destino):
        caminhos = self.encontra_caminhos(origem, destino)
        if not caminhos:
            return None, None  # Não há caminho entre os vértices
        maior_caminho = max(caminhos, key=len)
        return len(maior_caminho) - 1, maior_caminho  # Subtrai 1 do comprimento para obter o número de arestas


    # Método para verificar se o grafo é Euleriano
    def eh_euleriano(self):
        visitado = g.bfs(g.vertices[0])  # Realiza uma busca em largura a partir de um vértice arbitrário
        if len(visitado) != g.num_vertices():
            print("O grafo não é Euleriano porque não é conectado.")
            return
        for vertice in g.vertices:
            if g.grau(vertice)[2] % 2 != 0:
                print(f"O grafo não é Euleriano porque o vértice {vertice} tem grau ímpar.")
                return
        print("O grafo é Euleriano.")

    # Método para imprimir a lista de adjacências do grafo
    def imprime_lista_adjacencias(self):
        for vertice in self.lista_adjacencia:
            print(f'{vertice}: ', end='')
            for adj in self.lista_adjacencia[vertice]:
                print(f'{adj} -> ', end='')
            print(' ')

    # Método para realizar uma busca em largura a partir de um vértice
    def bfs(self, u):
        visitados = []
        lista = []
        lista.append(u)
        while lista:
            s = lista.pop(0)
            if s not in visitados:
                visitados.append(s)
                for x in self.lista_adjacencia[s]:
                    if x not in visitados:
                        lista.append(x[0])
        return visitados

    # Método para encontrar um caminho mínimo entre dois vértices usando busca em largura
    def bfs_caminho(self, u, destino):
        visitados = []
        lista = []
        lista.append(u)
        while lista:
            s = lista.pop(0)
            if s not in visitados:
                visitados.append(s)
                for x in self.lista_adjacencia[s]:
                    if x[0] == destino:
                        visitados.append(x[0])
                        return visitados
                    if x[0] not in visitados:
                        lista.append(x[0])
        return False

    # Método para encontrar os vértices a uma determinada distância de um vértice de origem
    def vertices_a_distancia(self, origem, distancia):
        if origem not in self.vertices:
            print("Vértice de origem não existe no grafo.")
            return []

        vertices_encontrados = set()
        fila = Queue()
        fila.put((origem, 0))  # (vértice, distância acumulada até o vértice)

        while not fila.empty():
            vertice_atual, dist_acumulada = fila.get()
            if dist_acumulada > distancia:
                break  # Parar a busca se a distância acumulada exceder a distância limite
            vertices_encontrados.add(vertice_atual)

            # Percorrer os vizinhos do vértice atual
            for vizinho, peso in self.lista_adjacencia[vertice_atual]:
                nova_distancia = dist_acumulada + peso
                if nova_distancia <= distancia and vizinho not in vertices_encontrados:
                    fila.put((vizinho, nova_distancia))

        return list(vertices_encontrados)

    # Método para adicionar vértices e arestas com base em uma estrutura de diretórios de arquivos
    def adicionaBasedados(self):
        path = "/content/drive/MyDrive/Amostra Enron - 2016"  # Caminho para a pasta raiz dos dados
        lista_users = os.listdir(path)  # Lista dos diretórios de usuários
        path += "/"
        for users in lista_users:
            path2 = path + users
            b = os.listdir(path2)
            for k in b:
                path3 = path2 + "/" + k
                if os.path.isdir(path3):  # Verifica se é um diretório
                    self.peganomes(path3)  # Chama o método para processar os arquivos

    # Método para extrair dados dos arquivos de e-mails e adicionar vértices e arestas correspondentes
    def peganomes(self, path3):
        for root, dirs, files in os.walk(path3):
            for file_name in files:
                pathfile = os.path.join(root, file_name)
                with open(pathfile, 'r') as file:
                    x = file.readline()
                    enviadopor = ""
                    recebidopor = []
                    acheienviado = False
                    acheirecebido = False
                    while x:
                        y = x.split()
                        if y and y[0] == "Subject:":
                            acheirecebido = True
                            break
                        if acheienviado:
                            for i in y:
                                if i == "To:":
                                    continue
                                if i[-1] == ",":
                                    i = i[:-1]
                                recebidopor.append(i)
                        if y and y[0] == "From:":
                            enviadopor = y[1]
                            acheienviado = True
                        x = file.readline()
                    if acheirecebido:
                        self.adiciona_vertice(enviadopor)
                        for i in recebidopor:
                            self.adiciona_vertice(i)
                            self.adiciona_aresta(enviadopor, i, 1)


g = Grafo()  # Instância da classe Grafo
g.adicionaBasedados()  # Adiciona vértices e arestas com base nos arquivos de e-mail

print(f'Número de vertices: {g.num_vertices()} ')
print("-------------------------------------------")
print(f'Número de arestas: {g.num_arestas()} ')
print("-------------------------------------------")
print('20 maiores graus de entrada: ')
g.vinte_maiores_graus_entrada()
print("-------------------------------------------")
print('20 maiores graus de saída: ')
g.vinte_maiores_graus_saida()
print("-------------------------------------------")
g.eh_euleriano()
print("-------------------------------------------")

print(g.bfs_caminho('jennifer.martinez@enron.com', 'richard.yeboah@enron.com'))

print(g.bfs_caminho('david.forster@enron.com', 'george.huan@enron.com'))

print(g.vertices_a_distancia('david.forster@enron.com', 10))

print(g.maior_caminho_minimo('david.forster@enron.com', 'george.huan@enron.com'))