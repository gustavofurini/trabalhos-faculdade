# -*- coding: utf-8 -*-
"""TRABALHOCACHE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cyvZFH_blone93zk6oTKQuVbIcJdRlMo
"""

from abc import abstractmethod
import sys

class IO:
    def __init__(self, entrada=sys.stdin, saida=sys.stdout):
        self.entrada = entrada  # ARMAZENA A ENTRADA
        self.saida = saida  # ARMAZENA A SAÍDA

    def output(self, s):
        print(s, end='', file=self.saida)

class EnderecoInvalido(Exception):
    def __init__(self, ender):
        self.ender = ender

    def __repr__(self):
        return str(self.ender)

class Memoria:
    # CLASSE MEMORIA COM CAPACIDADE COMO ARGUMENTO
    def __init__(self, capacidade):
        self._capacidade = capacidade  # ARMAZENA A CAPACIDADE DA MEMÓRIA

    # VERIFICA SE O ENDEREÇO É VÁLIDO
    def verifica_endereco(self, ender):
        if ender < 0 or ender >= self._capacidade:
            raise EnderecoInvalido(ender)

    # OBTER TAMANHO DA MEMÓRIA
    def tamanho(self):
        return self._capacidade  # RETORNA A CAPACIDADE

    @abstractmethod
    def read(self, ender):
        pass

    @abstractmethod
    def write(self, ender, val):
        pass

# CLASSE RAM HERDA DA MEMÓRIA
class RAM(Memoria):
    def __init__(self, k):
        super().__init__(2 ** k)  # INICIALIZA A MEMÓRIA
        self.memoria = [0] * self.tamanho()  # INICIALIZA LISTA DE MEMÓRIA COM LISTA DE ZEROS

    # LER O VALOR NA MEMÓRIA RAM
    def read(self, ender):
        super().verifica_endereco(ender)  # VERIFICA SE O ENDEREÇO É VÁLIDO
        return self.memoria[ender]  # RETORNA VALOR NA POSIÇÃO DO ENDEREÇO

    # ESCREVER VALOR NA MEMÓRIA RAM
    def write(self, ender, val):
        super().verifica_endereco(ender)  # VERIFICA SE O ENDEREÇO É VÁLIDO
        self.memoria[ender] = val  # ESCREVE O VALOR NA POSIÇÃO DO ENDEREÇO

class Cache(Memoria):
    # RECEBE CAPACIDADE, TAMANHO DA LINHA DE CACHE E RAM
    def __init__(self, capacidade, cache_line_size, ram):
        super().__init__(ram.tamanho())  # INICIALIZA A MEMÓRIA
        self.ram = ram  # ARMAZENA A MEMÓRIA RAM
        self.cache_line_size = cache_line_size  # ARMAZENA O TAMANHO DA LINHA DE CACHE
        self.cache_lines = capacidade // cache_line_size  # CALCULA O NÚMERO DE LINHAS DA CACHE
        self.cache = [None] * self.cache_lines  # INICIALIZA A CACHE COM NENHUMA INFORMAÇÃO
    def read(self, address):
          super().verifica_endereco(address)  # VERIFICA SE O ENDEREÇO É VÁLIDO

          # DETERMINA QUAL LINHA DA CACHE SERÁ USADA PARA BUSCAR A INFORMAÇÃO
          r = (address // self.cache_line_size) % self.cache_lines  # CALCULA O ÍNDICE DA LINHA NA CACHE (r)

          # CALCULA A TAG DO ENDEREÇO PARA VERIFICAR SE A LINHA DA CACHE É A CORRETA (t)
          t = (address // (self.cache_line_size * self.cache_lines))

          # CALCULA O DESLOCAMENTO DENTRO DA LINHA DA CACHE
          w = address % self.cache_line_size
          # NÚMERO DO BLOCOD NA RAM
          s = (t << (len(self.cache) + 6)) | (r << 6)

          # SE O VALOR ESTIVER PRESENTE NA CACHE E A TAG FOR IGUAL, É UM CACHE HIT
          if self.cache[r] is not None and self.cache[r]['tag'] == t:
              # PEGA O VALOR DA CAIXINHA DA CACHE
              result = self.cache[r]['data'][w]
          else:
              # SE NÃO ESTIVER NA CACHE, É UM CACHE MISS
              print(f'MISS: {address} [{s * self.cache_line_size}..{(s + 1) * self.cache_line_size - 1}]->L{r}')
              # BUSCA A INFORMAÇÃO NA RAM
              result = self.ram.read(address)
              # ATUALIZA A CACHE COM OS NOVOS DADOS
              self.update_cache(r, t)

          return result

    def write(self, address, val):
        super().verifica_endereco(address)

        # DETERMINA QUAL LINHA DA CACHE SERÁ USADA PARA ARMAZENAR A INFORMAÇÃO
        r = (address // self.cache_line_size) % self.cache_lines

        # CALCULA A TAG DO ENDEREÇO PARA VERIFICAR SE A LINHA DA CACHE É A CORRETA
        t = (address // (self.cache_line_size * self.cache_lines))

        # CALCULA O VALOR DO DESLOCAMENTO
        w = address % self.cache_line_size
        # NUMERO DO BLOCO NA RAM
        s = (t << (len(self.cache) + 6)) | (r << 6)

          # SE A LINHA DA CACHE JÁ EXISTE E A TAG É IGUAL, APENAS ATUALIZA A CACHE
        if self.cache[r] is not None and self.cache[r]['tag'] == t:
             # ATUALIZA A CAIXINHA DA CACHE
            self.cache[r]['data'][w] = val
             # TAMBÉM ATUALIZA NA RAM, PARA MANTER TUDO CONSISTENTE
            self.ram.write(address, val)
        else:
            # SE A LINHA DA CACHE NÃO EXISTE, SUBSTITUI A LINHA INTEIRA NA CACHE
            self.cache[r] = {'tag': t, 'data': [0] * self.cache_line_size}
            # COLOCA O NOVO VALOR NA CAIXINHA DA CACHE
            self.cache[r]['data'][w] = val
            # TAMBÉM ESCREVE O VALOR NA RAM
            self.ram.write(address, val)
            print(f'MISS: {address} L{r}->[{w * self.cache_line_size}..{(w + 1) * self.cache_line_size - 1}]')

      # ATUALIZA A CACHE
    def update_cache(self, r, t):
        if self.cache[r] is not None:
            # SE A LINHA DA CACHE FOI MODIFICADA, ESCREVE DE VOLTA NA RAM
            if any(self.cache[r]['data']):
                 # CALCULA O ENDEREÇO NA RAM ONDE OS DADOS DA CACHE DEVEM SER ESCRITOS
                 ram_address = (self.cache[r]['tag'] << (len(self.cache) + 6)) | (r << 6)
                 for i, value in enumerate(self.cache[r]['data']):
                     # ESCREVE CADA VALOR NA RAM
                     self.ram.write(ram_address + i, value)

          # LÊ OS DADOS DA RAM E ATUALIZA A CACHE
        ram_address = (t << (len(self.cache) + 6)) | (r << 6)
        # LÊ OS DADOS DA RAM E ATUALIZA A CAIXINHA DA CACHE COM OS NOVOS DADOS DA RAM
        self.cache[r] = {'tag': t, 'data': [self.ram.read(ram_address + i) for i in range(self.cache_line_size)]}

class CPU:
    def __init__(self, mem, io):
        self.mem = mem  # ARMAZENA A MEMÓRIA
        self.io = io  # ARMAZENA ENTRA E SAIDA
        self.PC = 0  # INICIALIZA CONTADOR
        self.A = self.B = self.C = 0

    # EXECUTA PROGRAMA
    def run(self, address):
            self.PC = address  # ENDEREÇO ATUAL
            self.A = self.mem.read(self.PC)  # LE O VALOR NA POSIÇÃO E ARMAZENA EM A
            #print(self.A)
            self.PC += 1
            self.B = self.mem.read(self.PC)  # LE O VALOR NA PRÓXIMA POSIÇÃO E ARMAZENA EM B
            #print(self.B)
            self.C = 1  # INICIALIZA C COM 1
            while self.A <= self.B:
                self.mem.write(self.A, self.C)  # ESCREVE O VALOR DE C NA MEMÓRIA NA POSIÇÃO A
                self.io.output(f'> {self.A} = {self.C}\n')
                self.C += 1
                self.A += 1

def main():
    try:
        io = IO(sys.stdin, sys.stdout)
        ram = RAM(22)
        cache = Cache(4 * 2**10, 64, ram)
        cpu = CPU(cache, io)

        inicio = 10

        print("Programa 1")
        ram.write(inicio, 118)
        ram.write(inicio + 1, 130)
        cpu.run(inicio)

        print("\nPrograma 2")
        cache.write(inicio, 4155)
        cache.write(inicio + 1, 4165)
        cpu.run(inicio)

    except EnderecoInvalido as e:
        print("Endereço inválido:", e.ender, file=sys.stderr)

if __name__ == '__main__':
    main()